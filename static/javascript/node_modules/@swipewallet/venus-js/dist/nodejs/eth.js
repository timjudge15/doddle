"use strict";
/**
 * @file Ethereum
 * @desc These methods facilitate interactions with the Ethereum blockchain.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports._createProvider = exports.getBalance = exports.getProviderNetwork = exports.trx = exports.read = void 0;
var ethers_1 = require("ethers");
var JsonRpc;
(function (JsonRpc) {
    JsonRpc[JsonRpc["EthSendTransaction"] = 0] = "EthSendTransaction";
    JsonRpc[JsonRpc["EthCall"] = 1] = "EthCall";
    // NetVersion,
})(JsonRpc || (JsonRpc = {}));
/**
 * This is a generic method for invoking JSON RPC's `eth_call` or `eth_send`
 *     with Ethers.js. This function supports the public `read` and `trx`
 *     methods in this module.
 *
 * @param {boolean} isWrite True for `eth_send` and false for `eth_call`.
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and Ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @hidden
 *
 * @returns {Promise<any>} Return value of the invoked smart contract member
 *     or an error object if the call failed.
 */
function _ethJsonRpc(jsonRpcMethod, address, method, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
parameters, options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new Promise(function (resolve, reject) {
        var provider = options._compoundProvider || _createProvider(options);
        var overrides = {
            gasPrice: options.gasPrice,
            nonce: options.nonce,
            value: options.value,
            chainId: options.chainId,
            from: options.from,
            gasLimit: options.gasLimit
        };
        parameters.push(overrides);
        var contract;
        var abi;
        if (options.abi) {
            // Assumes `method` is a string of the member name
            // Assumes `abi` is a JSON object
            abi = options.abi;
            contract = new ethers_1.ethers.Contract(address, abi, provider);
        }
        else {
            // Assumes `method` is a string of the member definition
            abi = [method];
            contract = new ethers_1.ethers.Contract(address, abi, provider);
            method = Object.keys(contract.functions)[1];
        }
        if (jsonRpcMethod === JsonRpc.EthSendTransaction) {
            contract[method].apply(null, parameters).then(function (result) {
                resolve(result);
            })["catch"](function (error) {
                try {
                    delete parameters[parameters.length - 1].privateKey;
                }
                catch (e) { }
                try {
                    delete parameters[parameters.length - 1].mnemonic;
                }
                catch (e) { }
                reject({
                    message: 'Error occurred during [eth_sendTransaction]. See {error}.',
                    error: error,
                    method: method,
                    parameters: parameters
                });
            });
        }
        else if (jsonRpcMethod === JsonRpc.EthCall) {
            contract.callStatic[method].apply(null, parameters).then(function (result) {
                resolve(result);
            })["catch"](function (error) {
                try {
                    delete parameters[parameters.length - 1].privateKey;
                }
                catch (e) { }
                try {
                    delete parameters[parameters.length - 1].mnemonic;
                }
                catch (e) { }
                reject({
                    message: 'Error occurred during [eth_call]. See {error}.',
                    error: error,
                    method: method,
                    parameters: parameters
                });
            });
        }
    });
}
/**
 * This is a generic method for invoking JSON RPC's `eth_call` with Ethers.js.
 *     Use this method to execute a smart contract's constant or non-constant
 *     member without using gas. This is a read-only method intended to read a
 *     value or test a transaction for valid parameters. It does not create a
 *     transaction on the block chain.
 *
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and Ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {Promise<any>} Return value of the invoked smart contract member or an error
 *     object if the call failed.
 *
 * @example
 * ```
 * const vBnbAddress = Venus.util.getAddress(Venus.vBNB);
 *
 * (async function() {
 *
 *   const srpb = await Venus.eth.read(
 *     vBnbAddress,
 *     'function supplyRatePerBlock() returns (uint256)',
 *     // [], // [optional] parameters
 *     // {}  // [optional] call options, provider, network, plus Ethers.js "overrides"
 *   );
 *
 *   console.log('vBNB market supply rate per block:', srpb.toString());
 *
 * })().catch(console.error);
 * ```
 */
function read(address, method, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
parameters, options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    return _ethJsonRpc(JsonRpc.EthCall, address, method, parameters, options);
}
exports.read = read;
/**
 * This is a generic method for invoking JSON RPC's `eth_sendTransaction` with
 *     Ethers.js. Use this method to create a transaction that invokes a smart
 *     contract method. Returns an Ethers.js `TransactionResponse` object.
 *
 * @param {string} address The Ethereum address the transaction is directed to.
 * @param {string} method The smart contract member in which to invoke.
 * @param {any[]} [parameters] Parameters of the method to invoke.
 * @param {CallOptions} [options] Options to set for `eth_sendTransaction`,
 *     (as JSON object), and Ethers.js method overrides. The ABI can be a string
 *     optional ABI of the single intended method, an array of many methods, or
 *     a JSON object of the ABI generated by a Solidity compiler.
 *
 * @returns {Promise<any>} Returns an Ethers.js `TransactionResponse` object or an error
 *     object if the transaction failed.
 *
 * @example
 * ```
 * const oneEthInWei = '1000000000000000000';
 * const vBnbAddress = '0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5';
 * const provider = window.ethereum;
 *
 * (async function() {
 *   console.log('Supplying BNB to the Venus Protocol...');
 *
 *   // Mint some vBNB by supplying BNB to the Venus Protocol
 *   const trx = await Venus.eth.trx(
 *     vBnbAddress,
 *     'function mint() payable',
 *     [],
 *     {
 *       provider,
 *       value: oneEthInWei
 *     }
 *   );
 *
 *   // const result = await trx.wait(1); // JSON object of trx info, once mined
 *
 *   console.log('Ethers.js transaction object', trx);
 * })().catch(console.error);
 * ```
 */
function trx(address, method, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
parameters, options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (parameters === void 0) { parameters = []; }
    if (options === void 0) { options = {}; }
    return _ethJsonRpc(JsonRpc.EthSendTransaction, address, method, parameters, options);
}
exports.trx = trx;
/**
 * This helps the Venus.js constructor discover which Ethereum network the
 *     developer wants to use.
 *
 * @param {Provider | string} [provider] Optional Ethereum network provider.
 *     Defaults to Ethers.js fallback mainnet provider.
 *
 * @hidden
 *
 * @returns {object} Returns a metadata object containing the Ethereum network
 *     name and ID.
 */
function getProviderNetwork(provider) {
    return __awaiter(this, void 0, void 0, function () {
        var _provider, networkId, network;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (provider._isSigner) {
                        _provider = provider.provider;
                    }
                    else {
                        _provider = provider;
                    }
                    if (!_provider.send) return [3 /*break*/, 2];
                    return [4 /*yield*/, _provider.send('net_version')];
                case 1:
                    networkId = _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    networkId = _provider._network.chainId;
                    _a.label = 3;
                case 3:
                    networkId = isNaN(networkId) ? 0 : +networkId;
                    network = ethers_1.ethers.providers.getNetwork(networkId) || { name: 'unknown' };
                    if (network.name === 'unknown') {
                        if (networkId === 97) {
                            // TODO -- should update later with Chapel
                            // 'testnet',
                            // {
                            //   name: 'Chapel',
                            //   networkId: 97,
                            //   chainId: 97,
                            // },
                            network = { chainId: 97, name: 'testnet' };
                        }
                        else if (networkId === 56) {
                            network = { chainId: 56, name: 'mainnet' };
                        }
                    }
                    return [2 /*return*/, {
                            id: networkId,
                            name: network.name === 'homestead' ? 'mainnet' : network.name
                        }];
            }
        });
    });
}
exports.getProviderNetwork = getProviderNetwork;
/**
 * Fetches the current Ether balance of a provided Ethereum address.
 *
 * @param {string} address The Ethereum address in which to get the BNB balance.
 * @param {Provider | string} [provider] Optional Ethereum network provider.
 *     Defaults to Ethers.js fallback mainnet provider.
 *
 * @returns {BigNumber} Returns a BigNumber hexadecimal value of the BNB balance
 *     of the address.
 *
 * @example
 * ```
 * (async function () {
 *
 *   balance = await Venus.eth.getBalance(myAddress, provider);
 *   console.log('My BNB Balance', +balance);
 *
 * })().catch(console.error);
 * ```
 */
function getBalance(address, provider) {
    return __awaiter(this, void 0, void 0, function () {
        var _provider, providerInstance, url, balance;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (typeof provider === 'object' && provider._isSigner) {
                        _provider = provider.provider;
                    }
                    else {
                        _provider = provider;
                    }
                    providerInstance = _createProvider({ provider: _provider });
                    if (!providerInstance.send && providerInstance.providerConfigs) {
                        url = providerInstance.providerConfigs[0].provider.connection.url;
                        providerInstance = new ethers_1.ethers.providers.JsonRpcProvider(url);
                    }
                    else if (!providerInstance.send && providerInstance.provider) {
                        providerInstance = providerInstance.provider;
                    }
                    return [4 /*yield*/, providerInstance.send('eth_getBalance', [address, 'latest'])];
                case 1:
                    balance = _a.sent();
                    return [2 /*return*/, balance];
            }
        });
    });
}
exports.getBalance = getBalance;
/**
 * Creates an Ethereum network provider object.
 *
 * @param {CallOptions} options The call options of a pending Ethereum
 *     transaction.
 *
 * @hidden
 *
 * @returns {object} Returns a valid Ethereum network provider object.
 */
function _createProvider(options) {
    if (options === void 0) { options = {}; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var provider = options.provider || (options.network || 'mainnet');
    var isADefaultProvider = !!ethers_1.ethers.providers.getNetwork(provider.toString());
    // Create an ethers provider, web3's can sign
    if (isADefaultProvider) {
        provider = ethers_1.ethers.getDefaultProvider(provider);
    }
    else if (typeof provider === 'object') {
        provider = new ethers_1.ethers.providers.Web3Provider(provider).getSigner();
    }
    else {
        // if (options.network === 'bsc-testnet') {
        //   const network = {
        //     name: 'Chapel',
        //     networkId: 97,
        //     chainId: 97,
        //   };
        //   provider = new ethers.providers.JsonRpcProvider(provider, network);
        // } else if (options.network === 'bsc-mainnet') {
        //   const network = {
        //     name: 'mainnet',
        //     networkId: 56,
        //     chainId: 56,
        //   };
        //   provider = new ethers.providers.JsonRpcProvider(provider, network);
        // } else {
        //   provider = new ethers.providers.JsonRpcProvider(provider);
        // }
        provider = new ethers_1.ethers.providers.JsonRpcProvider(provider);
    }
    // Add an explicit signer
    if (options.privateKey) {
        provider = new ethers_1.ethers.Wallet(options.privateKey, provider);
    }
    else if (options.mnemonic) {
        provider = new ethers_1.ethers.Wallet(ethers_1.ethers.Wallet.fromMnemonic(options.mnemonic), provider);
    }
    return provider;
}
exports._createProvider = _createProvider;
//# sourceMappingURL=eth.js.map